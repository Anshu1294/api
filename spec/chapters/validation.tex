\chapter{Validation}
\label{validation}

Validation is the process of verifying that some data obeys one or more pre-defined constraints. The Bean Validation specification \cite{bv11} defines an API to validate Java Beans. This chapter describes how JAX-RS provides native support for validating resource classes based on the concepts presented in \cite{bv11}.

\section{Constraint Annotations}
\label{constraint_annotations}

The Server API provides support for extracting request values and mapping them into Java fields, properties and parameters using annotations such as \code{@HeaderParam}, \code{@QueryParam}, etc. It also supports mapping of request entity bodies into Java objects via non-annotated parameters (i.e., parameters without any JAX-RS annotations). See Chapter \ref{resources} for additional information.

In earlier versions of JAX-RS, any additional validation of these values would need to be performed programmatically. This version of JAX-RS introduces support for declarative validation based on the Bean Validation specification \cite{bv11}. 

The Bean Validation specification \cite{bv11} supports the use of \emph{constraint annotations} as a way of declaratively validating beans, method parameters and method returned values. For example, consider the following resource class augmented with constraint annotations:

\begin{listing}{1}
@Path("/")
class MyResourceClass {

  @POST
  @Consumes("application/x-www-form-urlencoded")
  public void registerUser(
    @NotNull @FormParam("firstName") String firstName,
    @NotNull @FormParam("lastName") String lastName,
    @Email @FormParam("email") String email) {
    ...
  }
}
\end{listing}

The annotations \NotNull\ and \Email\ impose additional constraints on the form parameters \code{firstName}, \code{lastName} and \code{email}. The \NotNull\ constraint is built-in to the Bean Validation API; the \Email\ constraint is assumed to be user defined in the example above. These constraint annotations are not restricted to method parameters, they can be used in any location in which the JAX-RS binding annotations are allowed with the exception of constructors and property setters. Rather than using method parameters, the \code{MyResourceClass} shown above could have been written as follows:

\begin{listing}{1}
@Path("/")
class MyResourceClass {

  @NotNull @FormParam("firstName")
  private String firstName;

  @NotNull @FormParam("lastName")
  private String lastName;

  private String email;

  @FormParam("email")
  public void setEmail(String email) {
    this.email = email;
  }
  
  @Email
  public String getEmail() {
    return email;
  }
  ...
}
\end{listing}

Note that in this version, \code{firstName} and \code{lastName} are fields initialized via injection and \code{email} is a resource class property. Constraint annotations on properties are specified in their corresponding getters.

Constraint annotations are also allowed on resource classes. In addition to annotating fields and properties, an annotation can be defined for the entire class. Let us assume that \code{@NonEmptyNames} validates that one of the two \emph{name} fields in \code{MyResourceClass} is provided. Using such an annotation, the example above can be extended as follows:

\begin{listing}{1}
@Path("/")
@NonEmptyNames
class MyResourceClass {

  @NotNull @FormParam("firstName")
  private String firstName;

  @NotNull @FormParam("lastName")
  private String lastName;
  
  private String email;
  ...
}
\end{listing}

Constraint annotations on resource classes are useful for defining cross-field and cross-property constraints. 

\section{Annotations and Validators}

Annotation constraints and validators are defined in accordance with the Bean Validation specification \cite{bv11}. The \Email\ annotation shown above is defined using the Bean Validation \Constraint\ meta-annotation:

\begin{listing}{1}
@Target( { METHOD, FIELD, PARAMETER })
@Retention(RUNTIME)
@Constraint(validatedBy = EmailValidator.class)
public @interface Email {
  String message() default "{com.example.validation.constraints.email}"; 
  Class<?>[] groups() default {};
  Class<? extends Payload>[] payload() default {};
}
\end{listing}

The \Constraint\ annotation must include a reference to the validator class that will be used to validate decorated values. The \code{EmailValidator} class must implement \code{ConstraintValidator<Email, T>} where \code{T} is the type of values being validated. For example, 

\begin{listing}{1}
public class EmailValidator implements ConstraintValidator<Email, String> {
  public void initialize(Email email) { 
    ...
  }

  public boolean isValid(String value, ConstraintValidatorContext context) {
   ...
  }
}
\end{listing}

Thus, \code{EmailValidator} applies to values annotated with \Email\ that are of type \code{String}. Validators for different types can be defined for the same constraint annotation. 

\section{Entity Validation}

Request entity bodies can be mapped to resource method parameters. There are two ways in which these entities can be validated. If the request entity is mapped to a Java bean whose class is decorated with Bean Validation annotations, then validation can be enabled using \Valid:

\begin{listing}{1}
@StandardUser
class User { ... }

@Path("/")
class MyResourceClass {

  @POST
  @Consumes("application/xml")
  public void registerUser(@Valid User user) {
    ...
  }
}
\end{listing}

In this case, the validator associated with \code{@StandardUser} will be called to verify the request entity mapped to \code{user}. Alternatively, a new annotation can be defined and used directly on the resource method parameter. 

\begin{listing}{1}
@Path("/")
class MyResourceClass {

  @POST
  @Consumes("application/xml")
  public void registerUser(@PremiumUser User user) {
    ...
  }
}
\end{listing}

In the example above, \code{@PremiumUser} rather than \code{@StandardUser} will be used to validate the request entity. These two ways in which validation of entities can be triggered can also be combined by including \Valid\ in the list of constraints. The presence of \Valid\ will trigger validation of \emph{all} the constraint annotations decorating a Java bean class.

Response entity bodies returned from resource methods can be validated in a similar manner by annotating the resource method itself. To exemplify, assuming both \code{@StandardUser} and \code{@PremiumUser} are required to be checked before returning a user, the \code{getUser} method can be annotated as shown next:

\begin{listing}{1}
@Path("/")
class MyResourceClass {

  @GET
  @Path("{id}")
  @Produces("application/xml")
  @Valid @PremiumUser
  public User getUser(@PathParam("id") String id) {
    User u = findUser(id);
    return u;
  }
  ...
}
\end{listing}

Note that \code{@PremiumUser} is explicitly listed and \code{@StandardUser} is triggered by the presence of the \Valid\ annotation ---see definition of \code{User} class earlier in this section.

\section{Annotation Inheritance}

The rule for inheritance of constraint annotations is the same as that for all the other JAX-RS annotations (see Section \ref{annotationinheritance}). Namely, constraint annotations on methods and method parameters are inherited from interfaces and super-classes, with the latter taking precedence over the former when sharing common methods. For example:

\begin{listing}{1}
interface MyInterface {
  @GET
  @Path("{id}")
  @Produces("application/xml")
  @StandardUser
  public User getUser(@Pattern("[0-9]+") @PathParam("id") String id);
}

@Path("/")
class MyResourceClass implements MyInterface {

  public User getUser(String id) {
    User u = findUser(id);
    return u;
  }
  ...
}
\end{listing}

In the example above, the constraint annotations \code{@StandardUser} and \code{@Pattern} will be inherited by the \code{getUser} method in \code{MyResourceClass}. If the \code{getUser} method in \code{MyResourceClass} is decorated with any annotations, constraint or otherwise, all of the annotations in the interface \code{MyInterface} will be ignored. Naturally, since fields in super-classes cannot be overridden, all their annotations (including their constraint annotations) are inherited.

\section{Validation Phases and Error Reporting}
\label{validation_phases_and_error_reporting}

Constraint annotations are allowed in the same locations as the following annotations: \MatrixParam, \QueryParam, \PathParam, \CookieParam, \HeaderParam\ and \Context, {\em except} in class constructors and property setters. Specifically, they are allowed in resource method parameters, fields and property getters as well as resource classes, entity parameters and resource methods (return values). 

The default resource class instance lifecycle is per-request in JAX-RS. Implementations MAY support other lifecycles; the same caveats related to the use of other JAX-RS annotations in resource classes apply to constraint annotations. For example, a constraint validation annotating a constructor parameter in a resource class whose lifecycle is singleton will only be executed once.

When processing a request, is it desirable to collect and return as many violations as possible rather than to abort execution after the first violation is encountered. JAX-RS implementations are REQUIRED to use the following process to validate resource class instances after they have been instantiated:

\begin{description}
\item[Phase 1] Inject field values and initialize bean properties as described in Section \ref{resource_field}.
\item[Phase 2] Validate annotations on resource classes, fields and property getters. The order in which these validations are executed is implementation dependent.
\item[Phase 3] Validate annotations on parameters passed to the resource method matched. Note that @Valid is supported for method parameters.
\item[Phase 4] If no constraint violations found thus far, invoke resource method and validate returned value. Note that just like for method parameters, @Valid is supported for returned values.
\end{description}

The set of constraint violations is cumulative. If at the beginning of phase 4, the set of constraint violations is non-empty, implementations MUST throw a \code{ViolationException} (as subclass of \WebAppExc) with a status code 400 (Bad Request) and a list of all the violations encountered. If after phase 4, the set of constraint violations is non-empty, implementations MUST throw a \code{ViolationException} with a status code 500 (Internal Server Error) and a list of all the violations encountered. As described in Section~\ref{exceptionmapper}, an exception mapper can be defined for \code{ViolationException}; it is RECOMMENDED that JAX-RS implementations provide a default exception mapper for this type of exception.

\begin{ednote}
Should we require constructor parameter validation for beans that are not managed beans, CDI beans or EJBs? I.e., for beans directly managed by the JAX-RS implementation?
\end{ednote}

\begin{ednote}
A ViolationException currently holds a list of violation messages (strings) instead of ConstraintViolation to avoid a dependency with BV. Is this sufficient?
\end{ednote}

Instances returned by sub-resource locators are validated in the same manner but excluding phase 1 (see Section \ref{resource_field} for more information). Note that sub-resource locators can return instances containing other sub-resource locators: only the instance that is matched on step 3 in Section \ref{request_matching} is validated. This is the instance on which a resource method, as opposed to an intermediate resource locator, is matched.

\section{Exceptions}
\label{exceptions_validators}

When a validator method throws an exception, the \jaxrs\ runtime will attempt to map the exception to a suitable HTTP response in the same way as described for methods and locators in Section \ref{method_exc}.  As explained in Section \ref{exceptionmapper}, an application can supply exception mapping providers to customize this mapping.




