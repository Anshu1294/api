\chapter{Asynchronous Processing}
\label{asynchronous_processing}

This chapter describes the asynchronous processing capabilities in JAX-RS. Asynchronous processing is supported both in the Client API and in the Server API.

\section{Introduction}
\label{introduction_async}

Asynchronous processing is a technique that enables a better and more efficient use of processing threads. On the client side, a thread that issues a request may also be responsible for updating a UI component; if that thread is blocked waiting for a response, the user's perceived performance of the application will suffer. Similarly, on the server side, a thread that is processing a request should avoid blocking while waiting for an external event to complete so that it can process other requests that may be arriving to the server during that period\footnote{The maximum number of request threads is typically set by the administrator; if that upper bound is reached, subsequent requests will be rejected.}.

\section{Server API}
\label{server_api}

Synchronous processing requires a resource method to produce a response upon returning control back to the JAX-RS implementation. Asynchronous processing enables a resource method to inform the JAX-RS implementation that a response is not readily available upon return but will be produced at a future time. This can be accomplished by first {\em suspending} and later {\em resuming} the client connection on which the request was received. 

Let us illustrate these concepts via an example:

\begin{listing}{1}
@Path("/async/longRunning")
public class MyResource {

    @GET
    public void longRunningOp() {
        final AsynchronousResponse ar = AsynchronousResponse.suspend();
        Executors.newSingleThreadExecutor().submit(
            new Runnable() {
                public void run() {
                    executeLongRunningOp();
                    ar.resume("Hello async world!");
        } });
    } 
}
\end{listing}

In the example above, the method \code{longRunningOp} is called upon receiving a \code{GET} request. Rather than producing a response immediately, this method: (i) calls \code{AsynchronousResponse.suspend} to suspend the connection, (ii) forks a (non-request) thread to execute a long running operation and (iii) returns immediately. Once the execution of the long running operation is complete, the connection is resumed and the response returned by calling the method \code{resume} on the instance of \code{AsynchronousResponse} created when the connection was suspended.

\subsection{Timeouts and Fallback Responses}
\label{suspend_annotation}
% Update label!

A timeout value can be specified when suspending a connection to avoid waiting for a response indefinitely. The default unit is milliseconds, but any unit of type \code{java.util.concurrent.TimeUnit} can be used:

\begin{listing}{1}
@Path("/async/longRunning")
public class MyResource {
    
    @GET
    public void longRunningOp() {
        final AsynchronousResponse ar = 
            AsynchronousResponse.suspend(15, TimeUnit.SECONDS);
        ar.setFallbackResponse(getMyResponse());

        Executors.newSingleThreadExecutor().submit(
            new Runnable() {
                public void run() {
                    executeLongRunningOp();
                    ar.resume("Hello async world!");
        } });
    } 
    ...
}
\end{listing}

In this example, a timeout of 15 seconds is set when the connection is suspended. Additionally, a fallback response is set in case the timeout is reached before the connection is resumed.

JAX-RS implementations are REQUIRED to generate a \WebApplicationException\ with a service unavailable error response (HTTP 503 status) if the timeout value is reached and no fallback response is set. The exception MUST be processed as described in section~\ref{method_exc}. If a fallback response is set, JAX-RS implementations are REQUIRED to return the fallback response without generating an exception when the timeout is reached. An \code{IllegalStateException} MUST be thrown if attempting to suspend a connection more than once or resume a connection that is not suspended.

\section{EJB Resource Classes}
\label{async_ejbs}

As stated in Section~\ref{ejbs}, JAX-RS implementations in products that
support EJB must also support the use of stateless and singleton session beans
as root resource classes. When an EJB method is annotated with \code{@Asynchronous}, the 
EJB container automatically allocates the necessary resources for its execution. 
Thus, in this scenario, the use of an \code{Executor} is unnecessary to generate
an asynchronous response.

Consider the following example:

\begin{ednote}
This example requires JAX-RS implementations to (i) automatically suspend
a connection when EJB's @Asynchronous is specified and (ii) inject the response as a parameter.
\end{ednote}

\begin{listing}{1}
@Stateless 
@Path("/")
class EJBResource {

    @GET @Asynchronous
    public void longRunningOp(@Context AsynchronousResponse ar) {
        executeLongRunningOp();
        ar.resume("Hello async world!");
    }
}
\end{listing}

There is no explicit thread management is needed in this case since that is
under the control of the EJB container. Just like the other examples in this chapter,
the response is produced by calling \code{resume} on the \code{AsynchronousResponse}. Hence,
the return type of \code{longRunningOp} is simply \code{void}.

\section{Client API}
\label{client_api_async}

The fluent API supports asynchronous invocations as part of the invocation building process. By default, invocations are synchronous but can be set to run asynchronously by calling the \code{async} method and (optionally) registering an instance of \code{InvocationCallback} as shown next:

\begin{listing}{1}
Client client = ClientFactory.newClient();
Target target = client.target("http://example.org/customers/{id}");
target.pathParam("id", 123).request().async().get(
    new InvocationCallback<Customer>() {
        @Override
        public void completed(Customer customer) {
            // Do something
        }
        @Override
        public void failed(InvocationException error) {
            // Process error
        }
    });
\end{listing}

Note that in this example, the call to \code{get} after calling \code{async} returns immediately without blocking the caller's thread.
The response type is specified as a type parameter to \code{InvocationCallback}. The method \code{completed} is called when the invocation completes successfully and a response is available; the method \code{failed} is called with an instance of \code{InvocationException} when the invocation fails.

All asynchronous invocations return an instance of \code{Future<T>} here the type parameter \code{T} matches the type specified in \code{InvocationCallback}. This instance can be used to monitor or cancel the asynchronous invocation:

\begin{listing}{1}
Future<Customer> ff = target.pathParam("id", 123).request().async().get(
    new InvocationCallback<Customer>() {
        @Override
        public void completed(Customer customer) {
            // Do something
        }
        @Override
        public void failed(InvocationException error) {
            // Process error
        }
    });

// After waiting for a while ...
if (!ff.isDone()) {
    ff.cancel(true);
} 
\end{listing}

Even though it is recommended to pass an instance of \code{InvocationCallback} when executing an asynchronous call, it is not mandated. When omitted, the \code{Future<T>} returned by the invocation can be used to gain access to the response by calling the method \code{Future.get()}, which will return an instance of \code{T} if the invocation was successful or \code{null} if the invocation failed.






