\chapter{Filters and Interceptors}
\label{filters_and_interceptors}

Filters and entity interceptors can be registered for execution at well-defined extension points in \jaxrs\ implementations. They are used to extend an implementation in order to provide capabilities such as logging, confidentiality, authentication, entity compression, etc. 

\section{Introduction}
\label{introduction_filters}
Entity interceptors wrap around a method invocation at a specific extension point. 
Filters execute code at an extension point but without wrapping a method invocation.  There are four extension points for filters: ClientRequest, ClientResponse, ContainerRequest and ContainerResponse. There are two extension points for entity interceptors: ReadFrom and WriteTo.  For each of these extension points, there is a corresponding interface:

\begin{listing}{1}
public interface ClientRequestFilter {
    void filter(ClientRequestContext requestContext) throws IOException;
}
public interface ClientResponseFilter {
    void filter(ClientRequestContext requestContext, 
        ClientResponseContext responseContext) throws IOException;
}
public interface ContainerRequestFilter {
    void filter(ContainerRequestContext requestContext) throws IOException;
}
public interface ContainerResponseFilter {
    void filter(ContainerRequestContext requestContext, 
        ContainerResponseContext responseContext) throws IOException;
}
\end{listing}

\begin{listing}{1}
public interface ReaderInterceptor {
    Object aroundReadFrom(ReaderInterceptorContext context)
        throws java.io.IOException, javax.ws.rs.WebApplicationException;
}
public interface WriterInterceptor {
    void aroundWriteTo(WriterInterceptorContext context)
        throws java.io.IOException, javax.ws.rs.WebApplicationException;
}
\end{listing}

A {\em client} filter is a class that implements \ClientRequestFilter\ or \ClientResponseFilter\, or both. A {\em container} filter is a class that implements \ContainerRequestFilter\ or \ContainerResponseFilter, or both. An entity interceptor is a class that implements \ReaderInterceptor\ or \WriterInterceptor, or both. Filters and entity interceptors are providers and, as such, may be annotated with \Provider\ for automatic discovery.

In the Client API, a \ClientRequestFilter\ is executed as part of the invocation pipeline, before the HTTP request is delivered to the network; a \ClientResponseFilter\ is executed upon receiving a server response, before control is returned to the application. 
In the Server API, a \ContainerRequestFilter\ is executed upon receiving a request from a client; a \ContainerResponseFilter\ is executed as part of the response pipeline, before the HTTP response is delivered to the network. 

A \ContainerRequestFilter\ is a container filter executed before resource matching {\em unless} it is annotated with \PostMatching. The use of this annotation on this type of filters defines a new extension point for applications to use, namely PostContainerRequest. Certain \ContainerRequestContext\ methods may not be available at this extension point.

An entity interceptor implementing \ReaderInterceptor\ wraps around calls to \code{MessageBodyReader}'s method \code{readFrom}. An entity interceptor implementing \WriterInterceptor\ wraps around calls to \code{MessageBodyWriter}'s method \code{writeTo}. \jaxrs\ implementations are REQUIRED to call registered interceptors when mapping representations to Java types and vice versa. See Section \ref{entity_providers} for more information on entity providers.

\section{Filters}
\label{filters}

Filters are grouped into \emph{filter chains}. There is a separate filter chain for each extension points introduced in the previous section, namely: ClientRequest, ClientResponse, ContainerRequest, ContainerResponse and PostContainerRequest. Filters in a chain are sorted based on their priorities (see Section \ref{priorities}) and are executed in order. 

The following example shows an implementation of a container logging filter: each method simply logs the message and returns.

\begin{listing}{1}
@Provider
class LoggingFilter implements ContainerRequestFilter, 
                               ContainerResponseFilter {

    @Override
    public void filter(ContainerRequestContext requestContext) 
        throws IOException {
        log(requestContext);
    }

    @Override
    public void filter(ContainerRequestContext requestContext, 
        ContainerResponseContext responseContext) throws IOException {
        log(responseContext);
    }
    ...
}
\end{listing}

\ContainerRequestContext\ is a mutable class that provides request-specific information for the filter, such as request URI, message headers, message entity or request-scoped properties. The exposed setters allow (certain) modification of the request before its processing by a resource method. The dual class \ContainerResponseContext\ provides response-specific information.

Request filters implementing \ClientRequestFilter\ or \ContainerRequestFilter\ can stop the execution of their corresponding chains by calling \code{abortWith(Response)} in their corresponding context object. If this method is invoked, \jaxrs\ implementations are REQUIRED to abort execution of the chain and treat the response object as if produced by calling the resource method (Server API) or executing the HTTP invocation (Client API). For example, upon a cache hit, a client {\em caching} filter may call \code{abortWith(Response)} to abort execution and optimize network access.

As stated above, a \ContainerRequestFilter\ that is \emph{not} annotated with \PostMatching\ is executed upon receiving a client request but {\em before} a resource method is matched. Thus, this type of filter has the ability to modify the input to the matching algorithm (see Section~\ref{request_matching}) and, consequently, alter its outcome. 
The following example uses a \ContainerRequestFilter\ to tunnel requests via POST by using the X-HTTP-Method-Override header to overwrite the HTTP method prior to resource matching.

\begin{listing}{1}
@Provider
public class PostMethodOverrideFilter implements ContainerRequestFilter {

    @Override
    public void filter(ContainerRequestContext requestContext) 
        throws IOException {
        if (requestContext.getMethod().equalsIgnoreCase("POST")) {
            String override = requestContext.getHeaders()
                .getFirst("X-HTTP-Method-Override");
            if (override != null) {
                requestContext.setMethod(override);
            }
        }
    }
}
\end{listing}

\section{Entity Interceptors}

An entity interceptor implements interface \ReaderInterceptor\ or \WriterInterceptor, or both. There is an \emph{interceptor chain} for each kind of entity interceptor. Entity interceptors in a chain are sorted based on their priorities (see Section \ref{priorities}) and are executed in order. 

Entity interceptors wrap calls to the methods \code{readFrom} in classes implementing \code{MessageBodyReader} and \code{writeTo} in classes implementing \code{MessageBodyWriter}. An interceptor SHOULD explicitly call the context method \code{proceed} to continue the execution of the chain. Because of their wrapping nature, failure to call this method will prevent execution of the wrapped method in the corresponding message body reader or message body writer.

The following example shows an implementation of a GZIP entity interceptor that provides deflate and inflate capabilities~\footnote{This class is not intended to be a complete implementation of this interceptor.}.

\begin{listing}{1}
@Provider
class GzipInterceptor implements ReaderInterceptor, WriterInterceptor {

    @Override
    Object aroundReadFrom(ReaderInterceptorContext ctx) ... {
        InputStream old = ctx.getInputStream();
        ctx.setInputStream(new GZIPInputStream(old));
        try {
            return ctx.proceed();
        } finally {
            ctx.setInputStream(old);
        }
    }

    @Override
    void aroundWriteTo(WriterInterceptorContext context) ... {
        OutputStream old = ctx.getOutputStream();
        GZIPOutputStream gzipOutputStream = new GZIPOutputStream(old);
        ctx.setOutputStream(gzipOutputStream);
        try {
            ctx.proceed();
        } finally {
            gzipOutputStream.finish();
            ctx.setOutputStream(old);
        }
    }
    ...
}
\end{listing}

The context types, \ReaderInterceptorContext\ and \WriterInterceptorContext, provide read and write access to the parameters of the corresponding wrapped methods. In the example shown above, the input and output streams are wrapped and updated in the context object before proceeding. \jaxrs\ implementations MUST use the last parameter values set in the context object when calling the wrapped methods \code{MessageBodyReader.readFrom} and \code{MessageBodyWrite.writeTo}.

\section{Lifecycle}

By default, just like all the other providers, a single instance of each filter or entity interceptor is instantiated for each \jaxrs\ application. First the constructor is called, then any requested dependencies are injected, then the appropriate methods are called (simultaneously) as needed. Implementations MAY offer alternative lifecycle options beyond the default one. See Section \ref{lifecycle_and_environment} for additional information.

\section{Binding}

Binding is the process by which a filter or interceptor is associated with a resource class or method (Server API) or an invocation (Client API). The forms of binding presented in the next sections are only supported as part of the Server API. See Section \ref{binding_in_client_api} for binding in the Client API.

\subsection{Global Binding}
\label{global_binding}

Global binding is the default type of binding. A filter or interceptor that has no annotations or is only annotated with \Provider\ is bound globally, i.e.~its applicability is all the resource methods in an application. For example, the \code{LoggingFilter} defined in Section \ref{filters} is bound globally. If this filter is part of an application, requests and responses will be logged for all resource methods. 

\subsection{Name Binding}
\label{Name_Binding}

A filter or interceptor can be associated with a resource class or method by declaring a new \emph{binding} annotation \`{a} la CDI~\cite{jsr299}. These annotations are declared using the \jaxrs\ meta-annotation \NameBinding\ and are used to decorate both the filter (or interceptor) and the resource method or resource class. For example, the \code{LoggingFilter} defined in Section \ref{filters} can be bound to the method \code{hello} in \code{MyResourceClass}, instead of globally, as follows:

\begin{listing}{1}
@Provider
@Logged
class LoggingFilter implements ContainerRequestFilter, 
                               ContainerResponseFilter {
    ...
}
\end{listing}

\begin{listing}{1}
@Path("/")
public class MyResourceClass {
    @Logged
    @GET
    @Produces("text/plain")
    @Path("{name}")
    public String hello(@PathParam("name") String name) {
        return "Hello " + name;
    }
}
\end{listing}

According to the semantics of \code{LoggingFilter}, the request will be logged before the \code{hello} method is called and the response will be logged after it returns. The declaration of the \code{@Logged} annotation is shown next.

\begin{listing}{1}
@NameBinding
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(value = RetentionPolicy.RUNTIME)
public @interface Logged { }
\end{listing}

Binding annotations that decorate resource classes apply to all the resource methods defined in them. A filter or interceptor class can be decorated with multiple binding annotations. Similarly, a resource method can be decorated with multiple binding annotations.  Each binding annotation instance in a resource method denotes a set of filters and interceptors whose class definitions are decorated with that annotation (possibly among others). The final set of (static) filters and interceptors is the union of all these sets \footnote{By definition of {\em set}, any duplicate filters or interceptors in each individual set or the final set are eliminated.}; this set must be sorted based on priorities as explained in Section \ref{priorities}. 

\subsection{Dynamic Binding}

The annotation-based forms of binding presented thus far are {\em static}. Dynamic binding is also supported by using dynamic binders. A dynamic binder is a provider that implements the \DynamicBinder\ interface. Dynamic binder providers are consulted \emph{after} resource matching and are used to augment the set of filters and entity interceptors bound to a resource method. 

The following example defines a dynamic binder, \code{DynamicLoggingFilterBinder}, in order to dynamically bind a \code{LoggingFilter} ---assumed not globally bound for the purpose of this example--- with all resource methods in \code{MyResourceClass} that are annotated with \code{@GET}.

\begin{listing}{1}
@Provider
class DynamicLoggingFilterBinder implements DynamicBinder<LoggingFilter> {

  @Override
  public LoggingFilter getBoundInstance(ResourceInfo resourceInfo) {
    if (MyResourceClass.class.isAssignableFrom(
    	      resourceInfo.getResourceClass()) &&
        resourceInfo.getResourceMethod().isAnnotationPresent(GET.class)) {
          return new LoggingFilter();
    }
    return null;
 }
}
\end{listing}

\begin{ednote}
Shouldn't we return \code{Class<T>} instead of \code{T}?
\end{ednote}

\jaxrs\ implementations SHOULD resolve dynamic binders for filters and interceptors at most once for each resource method (typically at deployment time).

\subsection{Binding in Client API}
\label{binding_in_client_api}

Binding in the Client API is accomplished via API calls instead of annotations. \Client, \Invocation, \InvocationBuilder\ and \WebTarget\ are all configurable types: their configuration can be accessed by calling the \code{configure} method. See Sections \ref{configurable_types} for more information.

\section{Priorities}
\label{priorities}

The order in which filters and interceptors are executed as part of their corresponding chains is controlled by the \BindingPriority\ annotation.
Priorities are represented by integer numbers. Execution chains for extension points ContainerRequest, PostContainerRequest and ClientRequest are sorted in \emph{ascending order}; the lower the number the higher the priority. Execution chains for extension points ContainerResponse and ClientResponse are sorted in \emph{descending order}; the higher the number the higher the priority. These rules ensure that response filters are executed in reversed order of request filters.

The \code{BindingPriority} class defines a set of built-in priorities for security, header decorators, decoders and encoders. The default binding priority is \code{BindingPriority.USER}. For example, the priority of an authentication filter can be set as follows:

\begin{listing}{1}
@Provider
@Authenticated
@BindingPriority(BindingPriority.SECURITY)
public class AuthenticationFilter implements ContainerRequestFilter {
    ...
}
\end{listing}

Note that even though, as explained in Section \ref{binding_in_client_api}, annotations are not used for binding in the Client API, they are still used to define priorities. Therefore, if a priority other than the default is required, the \BindingPriority\ annotation must be used for a filter or interceptor registered using the Client API. 

The order in which filters and interceptors that belong to the same priority class are executed is implementation dependent.

\section{Exceptions}
\label{exceptions_filters_and_interceptors}

When a filter or interceptor method throws an exception, the \jaxrs\ runtime will attempt to map the exception as described in Section \ref{exceptions_providers}.  As explained in Section \ref{exceptionmapper}, an application can supply exception mapping providers to customize this mapping.
